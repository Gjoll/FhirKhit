using FhirKhit.SliceGen.CodeGen;
using FhirKhit.SliceGen.R4;
using FhirKhit.Tools;
using FhirKhit.Tools.R4;
using Hl7.Fhir.ElementModel;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Model;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;
using ElementDefinitionNode = FhirKhit.SliceGen.R4.ElementDefinitionNode;

namespace FhirKhit.SliceGen.CSApi
{
    public class CSCodeFormatter : ICodeFormatter
    {
        String className;
        CodeEditor code;
        CodeBlockNested nameSpaceBlock;
        CodeBlockNested classBlock;
        CodeBlockNested fieldsBlock;
        CodeBlockNested methodsBlock;
        CodeBlockNested subClassBlock;

        public SliceGenerator Gen { get; set; }

        /// <summary>
        /// Type of the fhir resource class that the profile is derived from (the resource it profiles)
        /// </summary>
        Type fhirBaseClassType;

        public CSCodeFormatter(SliceGenerator gen)
        {
            this.Gen = gen;
            this.code = new CodeEditor();
        }


        /// <summary>
        /// Start namespace.
        /// </summary>
        public bool StartNameSpace(String nameSpace)
        {
            this.nameSpaceBlock = this.code.Blocks.AppendBlock();
            this.nameSpaceBlock
                .AppendCode($"/*")
                .AppendCode($" * Code in this class was auto generated by SliceGen")
                .AppendCode($"*/")
                .AppendCode($"using System;")
                .AppendCode($"using System.Linq;")
                .AppendCode($"using System.Collections.Generic;")
                .AppendCode($"using System.Reflection;")
                .AppendCode($"using System.Text;")
                .AppendCode($"using Hl7.Fhir.Model;")
                .AppendCode($"using FhirKhit.SliceGen.SharedLib;")
                .BlankLine()
                .AppendCode($"namespace {nameSpace}")
                .OpenBrace()
                ;
            return true;
        }

        /// <summary>
        /// End namespace.
        /// </summary>
        public bool EndNameSpace()
        {
            this.nameSpaceBlock
                .CloseBrace()
                ;
            this.nameSpaceBlock = null;
            return true;
        }

        /// <summary>
        /// Start creating a class.
        /// </summary>
        public bool StartClass(String className, Type fhirBaseClassType)
        {
            this.fhirBaseClassType = fhirBaseClassType;
            this.className = className;
            string fhirTypeName = fhirBaseClassType.FriendlyName();

            this.classBlock = this.nameSpaceBlock.AppendBlock();
            this.classBlock
                .BlankLine()
                .SummaryOpen()
                .Summary($"Extension class to add slicing helper methods to {fhirTypeName}")
                .SummaryClose()
                .AppendLine($"public static class {className}")
                .OpenBrace()
                ;

            this.subClassBlock = classBlock.AppendBlock();
            this.subClassBlock.AppendLine($"#region {className} sub classes");

            this.fieldsBlock = classBlock.AppendBlock();
            this.fieldsBlock.AppendLine($"#region fields {className} fields");

            this.methodsBlock = classBlock.AppendBlock();
            this.methodsBlock.AppendLine($"#region methods {className} methods");

            return true;
        }

        /// <summary>
        /// End creating a class.
        /// </summary>
        public bool EndClass()
        {
            this.classBlock
                .CloseBrace()
                ;

            this.subClassBlock
                .AppendLine($"#endregion")
                ;

            this.fieldsBlock
                .AppendLine($"#endregion")
                ;

            this.methodsBlock
                .AppendLine($"#endregion")
                ;

            fieldsBlock = null;
            methodsBlock = null;

            this.classBlock = null;
            return true;
        }

        Element GetItem(ElementDefinitionNode sliceNode, String path)
        {
            const String fcn = nameof(GetItem);

            String[] pathParts = path.Split('.');
            ElementDefinitionNode node = sliceNode;
            for (Int32 i = 0; i < pathParts.Length; i++)
            {
                String pathPart = pathParts[i];
                ElementDefinitionNode next = null;
                foreach (ElementDefinitionNode n in node.ChildNodes)
                {
                    if (n.Name == pathPart)
                    {
                        next = n;
                        break;
                    }
                }
                if (next == null)
                {
                    this.Gen.ConversionError(this.GetType().Name, fcn, $"Cant find child node '{pathPart}' in '{sliceNode.FullPath()}'");
                    return null;
                }
                node = next;
            }
            return node.Element.Fixed;
        }

        /// <summary>
        /// Create slices on indicated node.
        /// </summary>
        /// <param name="elementNode">Element node containing discriminator</param>
        /// <returns></returns>
        public bool CreateSlice(ElementDefinitionNode elementNode)
        {
            CSSliceCreator c = new CSSliceCreator(this.className, this, this.subClassBlock, this.methodsBlock, elementNode, this.fhirBaseClassType);
            return c.CreateSlice();
        }

        public String GetCode() => this.code.ToString();

        /// <summary>
        /// Create method to set element at indicated path to passed value.
        /// </summary>
        public bool GenerateSetElements(CodeBlockNested block,
            ElementDefinitionNode node,
            String baseName,
            String path,
            String leafNodeValue = null)
        {
            const String fcn = nameof(GenerateSetElements);
            CodeBlockNested childBlock;

            if (block is null)
                throw new ArgumentNullException(nameof(block));
            if (node is null)
                throw new ArgumentNullException(nameof(node));
            if (path is null)
                throw new ArgumentNullException(nameof(path));

            void GenerateSetChildCode(ref string containerName,
                Type containerType,
                string itemName,
                Type itemType,
                String value)
            {
                if (containerName is null)
                    throw new ArgumentNullException(nameof(containerName));
                if (itemName is null)
                    throw new ArgumentNullException(nameof(itemName));

                String containerTypeName = containerType.FriendlyName();
                String itemTypeName = itemType.FriendlyName();

                if (value == null)
                    value = $"new {itemTypeName}()";

                if (containerType.IsList())
                {
                    childBlock
                        .AppendCode($"if ({containerName}.Count == 0)")
                        .AppendCode($"    {containerName}.Add({value});")
                        ;
                    containerName = $"{containerName}[0].{itemName}";
                }
                else
                {
                    childBlock
                        .AppendCode($"if ({containerName}.{itemName} == null)")
                        .AppendCode($"    {containerName}.{itemName} = {value};")
                        ;
                    containerName = $"{containerName}.{itemName}";
                }
            }

            String[] pathItems = path.Split('.');
            Int32 i = 0;

            if (pathItems[0] == node.Name)
                i += 1;

            childBlock = block.AppendBlock();
            String fullName = baseName;
            while (i < pathItems.Length)
            {
                String pathItem = pathItems[i];
                if (pathItem.StartsWith("resolve("))
                {
                    this.Gen.ConversionError(this.GetType().Name, fcn, $"TODO: FhirPath operator {pathItem} not implemented");
                    return false;
                }
                else if (pathItem.StartsWith("extension(\""))
                {
                    this.Gen.ConversionError(this.GetType().Name, fcn, $"TODO: FhirPath operator {pathItem} not implemented");
                    return false;
                }
                else if (pathItem.StartsWith("ofType("))
                {
                    this.Gen.ConversionError(this.GetType().Name, fcn, $"TODO: FhirPath operator {pathItem} not implemented");
                    return false;
                }
                else
                {
                    if (node.TryGetAnyChild(pathItem, out ElementDefinitionNode next) == false)
                    {
                        this.Gen.ConversionError(this.GetType().Name, fcn, $"Child {pathItem} not found");
                        return false;
                    }

                    PropertyInfo childProperty = node.FhirItemType.GetPropertyByFhirName(pathItem);
                    String value = null;
                    if (i == pathItems.Length - 1)
                        value = leafNodeValue;
                    GenerateSetChildCode(ref fullName, node.FhirItemType, childProperty.Name, next.FhirType, value);
                    node = next;
                }
                i += 1;
            }
            return true;
        }
    }
}
