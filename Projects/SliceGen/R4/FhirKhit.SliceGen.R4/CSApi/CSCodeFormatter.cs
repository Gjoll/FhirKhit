using FhirKhit.SliceGen.R4;
using FhirKhit.Tools;
using Hl7.Fhir.ElementModel;
using Hl7.Fhir.FhirPath;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Model;
using Hl7.FhirPath;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using ElementNode = FhirKhit.SliceGen.R4.ElementNode;

namespace FhirKhit.SliceGen.CSApi
{
    public class CSCodeFormatter : ICodeFormatter
    {
        CodeEditor code;
        CodeBlockNested nameSpaceBlock;
        CodeBlockNested classBlock;
        CodeBlockNested fieldsBlock;
        CodeBlockNested methodsBlock;
        CodeBlockNested subClassBlock;

        SliceGenerator gen;

        /// <summary>
        /// Type of the fhir resource class that the profile is derived from (the resource it profiles)
        /// </summary>
        Type fhirType;

        public CSCodeFormatter(SliceGenerator gen)
        {
            this.gen = gen;
            this.code = new CodeEditor();
        }


        /// <summary>
        /// Start namespace.
        /// </summary>
        public bool StartNameSpace(String nameSpace)
        {
            this.nameSpaceBlock = this.code.Blocks.AppendBlock();
            this.nameSpaceBlock
                .AppendCode($"/*")
                .AppendCode($" * Code in this class was auto generated by SliceGen")
                .AppendCode($"*/")
                .AppendCode($"using System;")
                .AppendCode($"using System.Linq;")
                .AppendCode($"using System.Collections.Generic;")
                .AppendCode($"using System.Reflection;")
                .AppendCode($"using System.Text;")
                .AppendCode($"using Hl7.Fhir.Model;")
                .AppendCode($"using FhirKhit.SliceGen.ShareLib;")
                .BlankLine()
                .AppendCode($"namespace {nameSpace}")
                .OpenBrace()
                ;
            return true;
        }

        /// <summary>
        /// End namespace.
        /// </summary>
        public bool EndNameSpace()
        {
            this.nameSpaceBlock
                .CloseBrace()
                ;
            this.nameSpaceBlock = null;
            return true;
        }

        /// <summary>
        /// Start creating a class.
        /// </summary>
        public bool StartClass(String className, Type fhirType)
        {
            string fhirTypeName = fhirType.FriendlyName();

            this.classBlock = this.nameSpaceBlock.AppendBlock();
            this.classBlock
                .OpenSummary()
                .AppendLine($"/// Extension class to add slicing helper methods to {fhirTypeName}")
                .CloseSummary()
                .AppendLine($"public static class {className}")
                .OpenBrace()
                ;

            this.subClassBlock = classBlock.AppendBlock();
            this.subClassBlock.AppendLine($"#region classes");

            this.fieldsBlock = classBlock.AppendBlock();
            this.fieldsBlock.AppendLine($"#region fields");

            this.methodsBlock = classBlock.AppendBlock();
            this.methodsBlock.AppendLine($"#region methods");

            return true;
        }

        /// <summary>
        /// End creating a class.
        /// </summary>
        public bool EndClass()
        {
            this.classBlock
                .CloseBrace()
                ;

            this.subClassBlock
                .AppendLine($"#endregion")
                ;

            this.fieldsBlock
                .AppendLine($"#endregion")
                ;

            this.methodsBlock
                .AppendLine($"#endregion")
                ;

            fieldsBlock = null;
            methodsBlock = null;

            this.classBlock = null;
            return true;
        }

        Element GetItem(ElementNode sliceNode, String path)
        {
            const String fcn = nameof(GetItem);

            String[] pathParts = path.Split('.');
            ElementNode node = sliceNode;
            for (Int32 i = 0; i < pathParts.Length; i++)
            {
                String pathPart = pathParts[i];
                ElementNode next = null;
                foreach (ElementNode n in node.Children)
                {
                    if (n.Name == pathPart)
                    {
                        next = n;
                        break;
                    }
                }
                if (next == null)
                {
                    this.gen.ConversionError(this.GetType().Name, fcn, $"Cant find child node '{pathPart}' in '{sliceNode.Path}'");
                    return null;
                }
                node = next;
            }
            return node.Element.Fixed;
        }

        /// <summary>
        /// Create slices on indicated node.
        /// </summary>
        /// <param name="elementNode">Element node containing discriminator</param>
        /// <returns></returns>
        public bool CreateSlice(ElementNode elementNode)
        {
            const String fcn = nameof(CreateSlice);

            Int32 patternCount = 1;
            CodeBlockNested fields;
            CodeBlockNested methods;
            ElementDefinition.DiscriminatorComponent[] discriminators = null;
            bool retVal = true;
            String accessorType = String.Empty;

            bool DefineSliceOnValueDiscriminator(ElementNode sliceNode,
                ElementDefinition.DiscriminatorComponent discriminator,
                String term)
            {
                Element b = this.GetItem(sliceNode, discriminator.Path);
                if (b == null)
                    return false;

                String sliceName = sliceNode.Element.SliceName;

                String patternMethod = $"Fix_{patternCount}";
                patternCount += 1;

                methods
                    .OpenSummary()
                    .AppendSummary($"Method to define fixed field used in slice accessor.")
                    .CloseSummary()
                    ;
                FhirConstruct.Construct(methods, b, patternMethod, "static", out String temp);
                fields
                    .AppendCode($"new SliceOnValueDiscriminator")
                    .OpenBrace()
                    .AppendCode($"Path = \"{discriminator.Path}\",")
                    .AppendCode($"Pattern = {patternMethod}()")
                    .CloseBrace(term)
                ;

                return true;
            }

            bool DefineDiscriminator(ElementNode sliceNode,
                ElementDefinition.DiscriminatorComponent discriminator,
                String term)
            {
                switch (discriminator.Type)
                {
                    case ElementDefinition.DiscriminatorType.Value:
                        return DefineSliceOnValueDiscriminator(sliceNode, discriminator, term);

                    default:
                        this.gen.ConversionError(this.GetType().Name, fcn, $"TODO: discriminator.Type {discriminator.Type} currently implemented. '{elementNode.Path}'");
                        return false;
                }
            }

            void CreateSliceAccessor(ElementNode sliceNode, String sliceClassName)
            {
                String sliceName = sliceNode.Element.SliceName;
                String baseTypeName = elementNode.FhirType.FriendlyName();

                this.methodsBlock
                    .OpenSummary()
                    .AppendSummary($"Create extension method to return slice {sliceName} on {elementNode.Name}")
                    .CloseSummary()
                    .AppendCode($"public static {sliceClassName} {sliceName}(this {baseTypeName} ptr)")
                    .OpenBrace()
                    .AppendCode($"{sliceClassName} retVal = new {sliceClassName}(ptr);")
                    .AppendCode($"return retVal;")
                    .CloseBrace()
                    ;
            }

            void CreateSliceAccessorClass(ElementNode sliceNode, out String sliceClassName)
            {
                String sliceName = sliceNode.Element.SliceName;
                sliceClassName = $"{sliceName}Impl";

                this.subClassBlock
                    .AppendCode($"public class {sliceClassName} : SliceAccessor<{accessorType}>")
                    .OpenBrace()
                    ;

                fields = this.subClassBlock.AppendBlock();
                fields.AppendLine($"#region fields");

                methods = this.subClassBlock.AppendBlock();
                methods.AppendLine($"#region methods");

                this.subClassBlock
                    .CloseBrace()
                    ;

                patternCount = 1;
                if (sliceName == null)
                {
                    this.gen.ConversionError(this.GetType().Name, fcn, $"Slice node '{elementNode.Path}' lacks slice name");
                    retVal = false;
                }
                else
                {
                    String sliceFieldName = $"slicing";

                    fields
                        .OpenSummary()
                        .AppendSummary($"Pointer to element containing all slice(s) elements")
                        .CloseSummary()
                        .AppendCode($"{elementNode.FhirType.FriendlyName()} items;")
                        .OpenSummary()
                        .AppendSummary($"slicing discriminator for {elementNode.Path} slice {sliceName}")
                        .CloseSummary()
                        .AppendCode($"static Slicing {sliceFieldName} = new Slicing")
                        .OpenBrace()
                        .AppendCode($"Discriminators = new ISliceDiscriminator[]")
                        .OpenBrace()
                        ;

                    for (Int32 i = 0; i < discriminators.Length; i++)
                    {
                        ElementDefinition.DiscriminatorComponent discriminator = discriminators[i];
                        String term = (i < discriminators.Length - 1) ? "," : "";
                        if (DefineDiscriminator(sliceNode, discriminator, term) == false)
                            retVal = false;
                    }

                    fields
                        .CloseBrace()
                        .CloseBrace(";")
                        ;

                    methods
                        .OpenSummary()
                        .AppendSummary($"{sliceClassName} constructor")
                        .CloseSummary()
                        .AppendCode($"public {sliceClassName}({elementNode.FhirType.FriendlyName()} items)")
                        .OpenBrace()
                        .AppendCode($"this.items = items;")
                        .AppendCode($"this.Slicing = {sliceFieldName};")
                        .CloseBrace()
                        ;
                }
                fields.AppendLine($"#endregion");
                methods.AppendLine($"#endregion");
            }

            if (elementNode is null)
                throw new ArgumentNullException(nameof(elementNode));

            ElementDefinition.SlicingComponent sliceComponent = elementNode.Element.Slicing;
            if (sliceComponent.Ordered == true)
            {
                this.gen.ConversionError(this.GetType().Name, fcn, $"TODO: Slicing.Ordered == true not currently implemented. '{elementNode.Path}'");
                return false;

            }

            if (sliceComponent.Rules != ElementDefinition.SlicingRules.Open)
            {
                this.gen.ConversionError(this.GetType().Name, fcn, $"TODO: Slicing.Rules != Open not currently implemented. '{elementNode.Path}'");
                return false;
            }

            discriminators = sliceComponent.Discriminator.ToArray();
            accessorType = elementNode.FhirItemType.FriendlyName();
            foreach (ElementNode sliceNode in elementNode.Slices)
            {
                CreateSliceAccessorClass(sliceNode, out String sliceClassName);
                CreateSliceAccessor(sliceNode, sliceClassName);
            }

            return retVal;
        }

        public String GetCode() => this.code.ToString();
    }
}
