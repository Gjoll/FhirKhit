using FhirKhit.Tools;
using Hl7.Fhir.Model;
using System;
using System.Linq;
using System.IO;
using Xunit;
using System.Text;
using Hl7.Fhir.Serialization;
using System.Reflection;
using Hl7.Fhir.Introspection;
using System.Collections.Generic;
using System.Diagnostics;
using System.Collections;


using FhirKhit.Tools.R4;
using FhirKhit.SliceGen.R4;
using Hl7.Fhir.Specification.Source;

namespace FhirKhit.CIMPL.XUnitTests
{
    /// <summary>
    /// Test the output test files generated in FhirKhit.SliceGen.XUnitTests.
    /// XUnitTests generated files in this project which are compiled and then
    /// tests are executed on the compiled output classes.
    /// </summary>
    public class CodeGenerationTest
    {

        void OutputProperty(FhirElementAttribute attribute,
            CodeBlockNested item,
            String min,
            String max)
        {
            String name = attribute.Name.ToMachineName();
            item
                .AppendCode($"Property: {name} {min}..{max}")
                ;
        }

        void GenerateCIMPLDataType(CodeBlockNested entryBlock,
            CodeBlockNested mapBlock,
            FHIRAllTypes fhirType)
        {
            String fhirTypeName = ModelInfo.FhirTypeToFhirTypeName(fhirType);
            Type fhirCSType = ModelInfo.GetTypeForFhirType(fhirTypeName);

            entryBlock
                .BlankLine()
                .AppendLine($"// Fhir data element {fhirTypeName} definition")
                .AppendCode($"Entry: {fhirTypeName}")
                ;


            CodeBlockNested item = entryBlock.AppendBlock();
            CodeBlockNested vars = entryBlock.AppendBlock();

            foreach (PropertyInfo pi in fhirCSType.GetProperties())
            {
                FhirElementAttribute attribute = pi.GetCustomAttribute<FhirElementAttribute>();
                if (attribute != null)
                {
                    String min;
                    String max;
                    Type csType;
                    if (pi.PropertyType.IsList())
                    {
                        min = "0";
                        max = "*";
                        csType = pi.PropertyType.GenericTypeArguments[0];
                    }
                    if (pi.PropertyType.IsNullable())
                    {
                        min = "0";
                        max = "1";
                        csType = pi.PropertyType.GenericTypeArguments[0];
                    }
                    else
                    {
                        csType = pi.PropertyType;
                        min = "1";
                        max = "1";
                    }

                    String name = attribute.Name.ToMachineName();
                    item
                        .AppendCode($"Property: {name} {min}..{max}")
                        ;

                    String typeName = null;
                    String csTypeName = csType.FriendlyName();
                    switch (csTypeName)
                    {
                        case "string":
                            OutputProperty(attribute, item, min, max);
                            break;

                        default:
                            typeName = ModelInfo.GetFhirTypeNameForType(pi.PropertyType);
                            if (String.IsNullOrEmpty(typeName))
                                throw new Exception($"Can not determine fhir type for c# type {csTypeName}");
                            break;
                    }

                    vars
                        .BlankLine()
                        .AppendCode($"Element: {name}")
                        .AppendCode($"Value: {typeName}")
                        ;

                    //    methods
                    //        .AppendCode($"case \"{attribute.Name}\":")
                    //        .OpenBrace()
                    //        .AppendCode($"ElementDefinition e = new ElementDefinition")
                    //        .OpenBrace()
                    //        .AppendCode($"Path = $\"{{parentPath}}.{attribute.Name}\",")
                    //        .AppendCode($"Short = \"{fhirType}.{attribute.Name} common attribute\",")
                    //        .AppendCode($"Min = {min},")
                    //        .AppendCode($"Max = \"{max}\"")
                    //        .CloseBrace(";")
                    //        .AppendCode($"retVal = new ElementNode(this, e, typeof({pi.PropertyType.FriendlyName()}), nameof({fhirCSType.FriendlyName()}.{pi.Name}));")
                    //        .AppendCode($"retVal.AutoGeneratedFlag = true;")
                    //        .AppendCode($"break;")
                    //        .CloseBrace(";")
                    //        ;
                }
            }
        }

        public static ZipSource Source
        {
            get
            {
                if (source == null)
                    source = new ZipSource("specification.zip");
                return source;
            }
        }
        static ZipSource source = null;

        /// <summary>
        /// Create the AddChildXXX methods of ElementNode.
        /// </summary>
        [Fact(DisplayName = "CodeGen.Dump")]
        [Trait("CodeGen", "CodeGen")]
        void Dump()
        {
            String dir = @"\Temp\Dump";

            if (Directory.Exists(dir) == false)
                Directory.CreateDirectory(dir);

            foreach (string y in Source.ListResourceUris())
            {
                String name = y.Substring(20).Replace('/', '-');
                Resource sd = Source.ResolveByUri(y);
                sd.SaveJson(Path.Combine(dir, $"{name}.json"));
            }
        }

        /// <summary>
        /// Create the AddChildXXX methods of ElementNode.
        /// </summary>
        [Fact(DisplayName = "CodeGen.GenerateCIMPLDataTypes")]
        [Trait("CodeGen", "CodeGen")]
        void GenerateCIMPLDataTypes()
        {
            CodeEditor entryEditor = new CodeEditor();
            CodeEditor mapEditor = new CodeEditor();

            CodeBlockNested entryBlock = entryEditor.Blocks.AppendBlock();
            entryBlock
                .AppendLine($"Grammar: DataElement 6.0")
                .AppendLine($"Namespace: fhir")
                .AppendLine($"Description: \"Base fhir element definitions. Autogenerated\"")
                ;

            CodeBlockNested mapBlock = mapEditor.Blocks.AppendBlock();
            mapBlock
                .AppendLine($"Grammar: Map 5.1")
                .AppendLine($"Namespace: fhir")
                .AppendLine($"Target: FHIR_R4")
                ;

            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Ratio);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Period);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Range);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Attachment);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Identifier);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Annotation);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.HumanName);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.CodeableConcept);

            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.ContactPoint);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Coding);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Money);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Address);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Timing);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Quantity);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.SampledData);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Signature);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Age);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Distance);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Duration);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Count);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.MoneyQuantity);
            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.SimpleQuantity);

            GenerateCIMPLDataType(entryBlock, mapBlock, FHIRAllTypes.Extension);

            entryEditor.Save(@"\Development\MITRE\cimpl\Fhir-BreastRadiologyReport\CIMPL\Fhir\BaseTypes.txt");
            mapEditor.Save(@"\Development\MITRE\cimpl\Fhir-BreastRadiologyReport\CIMPL\Fhir\BaseTypes_map_r4.txt");
        }

        /// <summary>
        /// Print out all primitive values used in api.
        /// </summary>
        [Fact(DisplayName = "CodeGen.ShowPrimitiveValues")]
        [Trait("CodeGen", "CodeGen")]
        void ShowPrimitiveValues()
        {
            List<String> primitives = new List<string>();
            List<String> nonPrimitives = new List<string>();

            foreach (FHIRAllTypes fhirType in Enum.GetValues(typeof(FHIRAllTypes)).OfType<FHIRAllTypes>())
            {
                String fhirTypeName = ModelInfo.FhirTypeToFhirTypeName(fhirType);
                Type csType = ModelInfo.GetTypeForFhirType(fhirTypeName);
                if (csType != null)
                {
                    foreach (PropertyInfo pi in csType.GetProperties())
                    {
                        FhirElementAttribute attribute = pi.GetCustomAttribute<FhirElementAttribute>();
                        if (attribute != null)
                        {
                            String friendlyName = pi.PropertyType.FriendlyName();
                            if (attribute.IsPrimitiveValue)
                            {
                                if (primitives.Contains(friendlyName) == false)
                                    primitives.Add(friendlyName);
                            }
                            else
                            {
                                if (nonPrimitives.Contains(friendlyName) == false)
                                    nonPrimitives.Add(friendlyName);
                            }
                        }
                    }
                }
            }

            Trace.WriteLine($"");
            Trace.WriteLine($"");
            Trace.WriteLine($"");
            Trace.WriteLine($"primitives");
            primitives.Sort();
            foreach (String primitive in primitives)
            {
                Trace.WriteLine($"case \"{primitive}\":");
            }


            Trace.WriteLine($"");
            Trace.WriteLine($"");
            Trace.WriteLine($"");
            Trace.WriteLine($"nonPrimitives");
            nonPrimitives.Sort();
            foreach (String nonPrimitive in nonPrimitives)
            {
                Trace.WriteLine($"case \"{nonPrimitive}\":");
            }
        }

        [Fact(DisplayName = "CodeGen.ShowPrimitives")]
        [Trait("CodeGen", "CodeGen")]
        void ShowPrimitives()
        {
            foreach (FHIRAllTypes fhirType in Enum.GetValues(typeof(FHIRAllTypes)).OfType<FHIRAllTypes>())
            {
                if (ModelInfo.IsPrimitive(fhirType))
                {
                    String fhirTypeName = ModelInfo.FhirTypeToFhirTypeName(fhirType);
                    if (ModelInfo.FhirTypeToCsType.TryGetValue(fhirTypeName, out Type csType) == false)
                        throw new Exception("");
                    Trace.WriteLine($"FHIRAllTypes.{fhirType}  FhirType {fhirTypeName} CSType {csType.FriendlyName()}");
                }
            }
        }
    }
}
