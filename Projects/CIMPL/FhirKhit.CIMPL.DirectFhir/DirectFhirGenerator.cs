using FhirKhit.Tools;
using FhirKhit.Tools.R4;
using Hl7.Fhir.Model;
using Hl7.Fhir.Serialization;
using Hl7.Fhir.Specification.Source;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;

namespace FhirKhit.CIMPL.DirectFhir
{
    public class DirectFhirGenerator : ConverterBase, IDisposable
    {
        public class SDefInfo
        {
            public enum TypeFlag
            {
                Unknown,
                Group,
                Entry
            }
            public TypeFlag TFlag = TypeFlag.Unknown;

            public StructureDefinition SDef;
        };


        Bundle fhirSDefsBundle;

        public String outputDir;
        public Dictionary<String, CodeEditor> editorDict = new Dictionary<string, CodeEditor>();

        public String NSBase => "fhir";

        public String NameSpace(params String[] path)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append($"{NSBase}");
            foreach (String pathItem in path)
                sb.Append($".{pathItem.ToLower()}");

            return sb.ToString();
        }


        String FhirSDefsPath => Path.Combine(this.outputDir, "StructureDefinitions.json");
        String GeneratedPath => Path.Combine(this.outputDir, "Generated");

        Bundle FhirSDefsBundle
        {
            get
            {
                if (this.fhirSDefsBundle == null)
                {
                    if (File.Exists(this.FhirSDefsPath) == false)
                        return null;

                    FhirJsonParser parser = new FhirJsonParser();
                    this.fhirSDefsBundle = parser.Parse<Bundle>(File.ReadAllText(this.FhirSDefsPath));
                }
                return this.fhirSDefsBundle;
            }
        }

        Dictionary<String, SDefInfo> items;
        ZipSource source;

        public DirectFhirGenerator(String outputDir)
        {
            this.outputDir = outputDir;
            if (Directory.Exists(this.GeneratedPath) == false)
                Directory.CreateDirectory(this.GeneratedPath);
            else
                DirHelper.CleanDir(this.GeneratedPath);

            this.source = new ZipSource("specification.zip");
            this.items = new Dictionary<string, SDefInfo>();
        }



        /// <summary>
        /// Converrt string to a desciption string
        /// </summary>
        /// <param name="path"></param>
        /// <returns></returns>
        public String ToDescription(Markdown description)
        {
            if (description is null)
                throw new ArgumentNullException(nameof(description));

            return description.ToString().Replace("\"", "'");
        }


        /// <summary>
        /// Create code editor for new entry and save it in save editor list.
        /// </summary>
        /// <param name="path"></param>
        /// <returns></returns>
        public CodeBlockNested CreateEntryEditor(String path)
        {
            const String fcn = "CreateEntryEditor";

            if (this.editorDict.ContainsKey(path) == true)
                throw new ConvertErrorException(this.GetType().Name, fcn, $"Path {path} has already been processed.");

            CodeEditor codeEditor = new CodeEditor();

            codeEditor.SavePath = Path.Combine(this.GeneratedPath, $"{path}.txt");

            CodeBlockNested block = codeEditor.Blocks.AppendBlock();
            block
                .AppendLine($"Grammar: DataElement 6.0")
                .AppendLine($"Namespace: {this.NameSpace(path)}")
                .AppendLine($"Description: \"Fhir {path} definition. Autogenerated\"")
                ;

            this.editorDict.Add(path, codeEditor);
            return block;
        }


        void DoProcessFhirElement(SDefInfo sDefInfo,
            CodeBlockNested mainBlock)
        {
            const string fcn = "ProcessSpecialiation";

            StructureDefinition sDef = sDefInfo.SDef;

            String parent = sDef.BaseDefinition?.LastUriPart();
            String description = this.ToDescription(sDef.Description);
            // remove items that derive directly from primitives.
            switch (parent)
            {
                case "boolean":
                case "integer":
                case "decimal":
                case "uri":
                case "string":
                case "base64Binary":
                case "instant":
                case "dateTime":
                case "time":
                case "oid":
                case "id":
                case "markdown":
                case "unsignedInt":
                case "positiveInt":
                case "xhtml":
                    this.ConversionInfo(this.GetType().Name, fcn, $"Ignoring '{sDef.Url}' because it derives from primitive '{parent}'");
                    return;
            }

            ConvertFhirClass cfc = new ConvertFhirClass(this, sDefInfo, mainBlock);
            cfc.Convert();
        }

        /// <summary>
        /// Process one fhir element
        /// </summary>
        /// <param name="sDefInfo"></param>
        /// <param name="mainBlock"></param>
        void ProcessFhirElement(SDefInfo sDefInfo,
                        CodeBlockNested mainBlock)
        {
            StructureDefinition sDef = sDefInfo.SDef;

            String baseDefinition = sDef.BaseDefinition;
            switch (baseDefinition)
            {
                case "http://hl7.org/fhir/StructureDefinition/Extension":
                    break;

                default:
                    if (
                        (sDef.Derivation == StructureDefinition.TypeDerivationRule.Specialization) ||
                        (sDef.Url == "http://hl7.org/fhir/StructureDefinition/Resource")
                        )
                        this.DoProcessFhirElement(sDefInfo, mainBlock);
                    break;
            }
        }

        /// <summary>
        /// To save time, store all structure definitions in a fhir bundle file. This need only be run when we get a new 
        /// FHIR version.
        /// </summary>
        void StoreFhirElements()
        {
            // const String fcn = "StoreFhirElements";

            this.fhirSDefsBundle = new Bundle();
            foreach (string uri in this.source.ListResourceUris())
            {
                StructureDefinition sDef = this.source.ResolveByUri(uri) as StructureDefinition;
                if (sDef != null)
                {
                    // This is to get rid of the http://....//de-... entries.
                    if (sDef.Snapshot.Element[0].Path.Split('.').Length == 1)
                        this.fhirSDefsBundle.AddResourceEntry(sDef, sDef.Url);
                }
            }
            this.fhirSDefsBundle.SaveJson(this.FhirSDefsPath);
        }

        void LoadFhirElements()
        {
            // const String fcn = "LoadFhirElements";

            foreach (StructureDefinition sDef in this.FhirSDefsBundle.GetResources())
            {
                SDefInfo sDefInfo = new SDefInfo
                {
                    SDef = sDef
                };

                switch (sDef.Url)
                {
                    case "http://hl7.org/fhir/StructureDefinition/Element":
                        sDefInfo.TFlag = SDefInfo.TypeFlag.Group;
                        break;

                    case "http://hl7.org/fhir/StructureDefinition/Resource":
                        sDefInfo.TFlag = SDefInfo.TypeFlag.Entry;
                        break;
                    default:
                        sDefInfo.TFlag = SDefInfo.TypeFlag.Unknown;
                        break;
                }

                this.items.Add(sDef.Url, sDefInfo);
            }
        }

        SDefInfo GetTypedSDef(String path)
        {
            const String fcn = "GetTypedSDef";

            if (this.items.TryGetValue(path, out SDefInfo sDef) == false)
                throw new ConvertErrorException(this.GetType().Name, fcn, $"Internal error. Item {path} not in dictionary");

            // If TFlag s unknown, use parents TFlag value.
            if (sDef.TFlag == SDefInfo.TypeFlag.Unknown)
            {
                SDefInfo parentInfo = this.GetTypedSDef(sDef.SDef.BaseDefinition);
                sDef.TFlag = parentInfo.TFlag;
            }

            return sDef;
        }

        /// <summary>
        /// Process all fhir elements.
        /// </summary>
        void ProcessFhirElements()
        {
            const String fcn = "ProcessFhirElements";

            CodeBlockNested mainBlock = CreateEntryEditor("Main");

            foreach (string path in this.items.Keys)
            {
                SDefInfo sDef = this.GetTypedSDef(path);
                this.ProcessFhirElement(sDef, mainBlock);
            }

            foreach (CodeEditor ce in this.editorDict.Values)
                ce.Save();
            this.editorDict.Clear();
        }

        public Int32 CreateBundle()
        {
            try
            {
                this.StoreFhirElements();
            }
            catch (ConvertErrorException err)
            {
                this.ConversionError(err.FileName, err.MethodName, err.Message);
            }
            catch (Exception err)
            {
                this.ConversionError(this.GetType().Name, "Execute", err.Message);
            }

            return this.Errors.Any() ? -1 : 0;
        }

        public Int32 GenerateBaseClasses()
        {
            try
            {
                if (File.Exists(this.FhirSDefsPath) == false)
                    this.StoreFhirElements();

                this.LoadFhirElements();
                this.ProcessFhirElements();
            }
            catch (ConvertErrorException err)
            {
                this.ConversionError(err.FileName, err.MethodName, err.Message);
            }
            catch (Exception err)
            {
                this.ConversionError(this.GetType().Name, "Execute", err.Message);
            }

            return this.Errors.Any() ? -1 : 0;
        }

        public void Dispose()
        {
        }
    }
}
